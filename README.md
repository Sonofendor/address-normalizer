# Стандартизация адреса
## Введение
Данная задача решалась для того чтобы связать таблицы с данными из разных источников. Например, если есть таблица с информацией о юр. лицах на сайте госзакупок и отдельно таблица с пользователями hh.ru, но нет полей (ИНН, скажем) которые однозначно говорят о том, что перед нами одна и та же компания. Поэтому пользователи сравниваются по нескольким полям вроде названия, телефона и, причина почему мы здесь, адреса. Но сравнивать адрес просто по Fuzzy distance бесполезно, потому что между улицей «1 Тверской-Ямской» и «3 Тверской-Ямской» всего 1 замена, а между ул. «Ак. Волгина» и ул. «Академика Волгина» — 7. А уж между «Россия, Москва, ул. Академика Волгина, 8» и «Ак. Волгина, 8». И тут уже ничего не поделаешь, этот метод просто абсолютно не подойдёт.
Правда, сразу сделаем отступление: если сравнивать эти адреса с неким эталоном, то результат будет на порядок лучше, но об этом позже.
## Текущий вариант
Я пропущу те вариации, которые привели к этому решению, их суть заключается в том, что без знания абсолютно всех адресов хотя бы в России, эта система не будет давать хороших результатов.
## Требования для реализации
1.	50Гб дискового пространства
2.	Python 3 + библиотеки pandas, simpledbf и elasticsearch
3.	Elasticsearch 5.4 + Kibana 5(опционально)
4.	Полная БД ФИАС в формате dbf (https://fias.nalog.ru/Updates.aspx )
## Алгоритм сборки
Для начала надо загрузить весь ФИАС в elastic. Для этого надо запустить «FIAS to elastic.ipynb» и по порядку всё выполнить. Загрузка полнотекстовых адресов занимает около 7 часов. Загрузка всех домов ещё 9.
После этого можно пользоваться ensemble.py. Главный метод там — standardize(string), который как раз и находит адрес в ФИАС и возвращает его стандартизованный вид.

## Принцип работы
Задача: разбить одно поле (адреса) на несколько полей, таких как дом, улица, город итд
Так как все адреса принципиально не отличаются друг от друга, то набор этих полей уже заранее известен. Порядок их в строке может незначительно меняться, но обычно он один и тот же: Индекс, город, улица, дом, корпус, квартира. Каждое из этих полей заполняется совершенно разными значениями, которые практически никогда не пересекаются, поэтому словарный подход здесь будет как никогда актуален.
Вся идея свести задачу извлечения полей к задаче поиска адреса в базе данных.
При этом некоторые поля, такие как адрес и номер дома гораздо более надёжно извлекать эвристически, нежели поиском. 

Извлечение адресов происходит в следующие этапы:
1.	Детекция полей по шаблону
    *	Извлечение индекса
    *	Извлечение номера дома/корпуса
2.	Определение границ названия улицы/города
3.	Поиск улицы и города в БД ФИАС
4.	Поиск дома и корпуса для данной улицы в ФИАС

### Детекция полей по шаблону
#### Индекс
Опытным путём было установлено, что любая последовательность из 6 цифр в адресе – это индекс. Поэтому индекс сразу определяется и извлекается из строки.
#### Номер дома/корпуса
Номера дома, корпуса, строения, квартир и офисов обычно записывают рядом с указанием что есть что, например «д3 к 2 стр 1». Все возможные вариации и названия таких последовательностей имеется в словаре и детектор физически отделяет такие последовательности из адреса: 
1.	Токенизирует всю строку адреса
2.	Ищет к каждому слову в адресе совпадение в словаре
3.	Помечает цифры в адресе
4.	Ищет самую длительную последовательность цифр и токенов из словаря
5.	Считает её номером дома/корпуса и отделяет её от строки адреса
6.	По шаблону «за типом токена следует его номер» (дом 5 корпус  1) адрес дома/корпуса записывается в память
### Определение границ названия улицы/города
Всё что осталось от адреса на этапе детекции считается названием улицы, города и региона. 
Так как токенизация операция односторонняя, в программе существует процедура поиска по токенам в строке, используя регулярные выражения. Шаблон следующий: «токен\*токен\*токен\*…\*токен», при этом важно чтобы алгоритм поиска был не жадным, иначе будут сюрпризы в виде «ул Донская, д 4а стр6» вместо «ул Донская, д 4а стр6» (здесь жирным помечено попадание в токен, а нижним подчёркиванием в wildcard-символ)
### Поиск улицы и города в БД ФИАС
Всё что осталось от строки адреса ищется в БД ФИАС с помощью elastic search. Под капотом это выглядит следующим образом: строка токенизируется и между каждым токеном ставится логическое «ИЛИ». То есть ищется максимальное количество попаданий между строкой адреса и стандартизированной строкой адреса в ФИАС. Небольшой тюнинг этого запроса изменяет известные варианты написания слов «город, область …» на их эквиваленты в ФИАС. Если и в ФИАС такие слова записаны разными способами, то вписываются все способы, но вес (значок ^ в запросе)  таких комбинаций следует уменьшить пропорционально количеству вариантов.
Также в запросе можно добавить fuzzy (~ после токена) для всех слов длиннее пяти, чтобы elastic попытался найти не только точное совпадение слова, но и похожие варианты. Иногда это помогает, иногда нет. Вместе с числом попаданий растёт число ошибок, так что общая точность не увеличивается.
Elastic возвращает нам всё что нужно знать об этом адресе: и название улицы и города и даже уникальный идентификатор, что как раз самое важное.
### Поиск дома и корпуса для данной улицы в ФИАС
С номером дома всё не просто, поэтому алгоритм следующий: по данному GUID ищется номер дома, номер корпуса и строения, которые уже извлечены из адреса. И тут возникает вопрос кому верить: ФИАС или пользователю; часто бывает что совпадение по разным причинам не находится в ФИАС (хотя бы потому что не все различают «строение» и «корпус») и было решено использовать в таком случае номер дома и корпус, которые были извлечены при парсинге. Если всё хорошо, то ФИАС возвращает GUID конкретного дома.

